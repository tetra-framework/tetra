{
  "version": 3,
  "sources": ["../../../js/tetra.core.js", "../../../js/tetra.js"],
  "sourcesContent": ["\nconst Tetra = {\n  ws: null,\n  pendingSubscriptions: new Map(), // Store subscriptions until WS is ready\n  offlineCallQueue: [], // Queue for method calls made while offline\n  queueRetryTimer: null, // Timer for periodic queue retry attempts\n\n  debug(...args) {\n    // Only output debug messages when DEBUG is enabled\n    if (window.__tetra_debug) {\n      console.debug(...args);\n    }\n  },\n\n  init() {\n    Alpine.magic('static', () => Tetra.$static);\n    // Initialize WebSocket connection immediately, if in use\n    if(window.__tetra_useWebsockets) {\n      this.ensureWebSocketConnection();\n    }\n    // Handle initial messages passed from the server\n    if (window.__tetra_messages) {\n      this.handleInitialMessages(window.__tetra_messages);\n      delete window.__tetra_messages;\n    }\n\n    // Initialize global subscription store\n    if (!Alpine.store('tetra_subscriptions')) {\n      Alpine.store('tetra_subscriptions', {});\n    }\n\n    // Initialize online status store\n    this.initOnlineStatusStore();\n\n    // Listen for browser online/offline events\n    this.initBrowserOnlineDetection();\n  },\n  initOnlineStatusStore() {\n    if (this.onlineStatusInitialized) return;\n    this.onlineStatusInitialized = true;\n\n    if (typeof Alpine !== 'undefined') {\n      if (!Alpine.store('tetraStatus')) {\n        Alpine.store('tetraStatus', {\n          online: true,\n          lastActivity: Date.now(),\n          update() {\n            this.online = true;\n            this.lastActivity = Date.now();\n          }\n        });\n      }\n    }\n\n    const defaultTimeout = window.__tetra_onlineTimeout || 10000;\n    if (this.offlineTimeout) {\n      clearTimeout(this.offlineTimeout);\n    }\n    this.offlineTimeout = setTimeout(() => this.checkOnlineStatus(), defaultTimeout);\n\n    // Also update on manual reconnect\n    document.addEventListener('tetra:websocket-connected', () => this.updateOnlineStatus());\n  },\n  updateOnlineStatus() {\n    if (typeof Alpine !== 'undefined') {\n      const store = Alpine.store('tetraStatus');\n      if (store) {\n        store.update();\n      }\n    }\n    \n    if (this.offlineTimeout) {\n      clearTimeout(this.offlineTimeout);\n    }\n    const timeout = window.__tetra_onlineTimeout || 10000;\n    this.offlineTimeout = setTimeout(() => this.checkOnlineStatus(), timeout);\n    \n    if (this.pingTimeout) {\n        clearTimeout(this.pingTimeout);\n    }\n  },\n  checkOnlineStatus() {\n    if (this.pingTimeout) {\n      clearTimeout(this.pingTimeout);\n    }\n    // If we haven't had activity, try to ping the server\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({\n        protocol: \"tetra-1.0\",\n        type: \"ping\"\n      }));\n      // Set another timeout to check if we got a response\n      const timeout = window.__tetra_pingTimeout || 5000;\n      this.pingTimeout = setTimeout(() => this.setOfflineStatus(), timeout);\n    } else {\n      this.setOfflineStatus();\n    }\n  },\n  setOfflineStatus() {\n    if (typeof Alpine !== 'undefined') {\n        const store = Alpine.store('tetraStatus');\n        if (store && store.online !== false) {\n          store.online = false;\n          document.dispatchEvent(new CustomEvent('tetra:websocket-disconnected'));\n        }\n      }\n  },\n\n  initBrowserOnlineDetection() {\n    // Listen for browser's online/offline events\n    // These fire when DevTools switches offline mode or actual network changes\n    if (this.browserOnlineDetectionInitialized) return;\n    this.browserOnlineDetectionInitialized = true;\n\n    window.addEventListener('online', () => {\n      Tetra.debug('Browser detected network online');\n      this.updateOnlineStatus();\n\n      // Try to reconnect WebSocket if it's not connected\n      if (window.__tetra_useWebsockets) {\n        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n          this.ensureWebSocketConnection();\n        }\n      }\n\n      // Process offline queue when we come back online\n      if (this.offlineCallQueue.length > 0) {\n        Tetra.debug(`Browser online event: processing ${this.offlineCallQueue.length} queued calls`);\n        // Small delay to ensure connection is stable\n        setTimeout(() => {\n          this.processOfflineCallQueue();\n        }, 500);\n      }\n    });\n\n    window.addEventListener('offline', () => {\n      Tetra.debug('Browser detected network offline');\n      this.setOfflineStatus();\n    });\n  },\n\n  handleInitialMessages(messages) {\n    // We need to wait for Alpine components to be ready before dispatching events to them.\n    // However, since we use 'defer' for tetra.js and Alpine, they should be ready around the same time.\n    // To be safe, we can use Alpine.nextTick or a small timeout if needed, but \n    // usually dispatching on document should work if components listen there.\n    messages.forEach((message) => {\n      document.dispatchEvent(new CustomEvent('tetra:new-message', {\n        detail: message,\n        bubbles: true\n      }));\n    });\n  },\n  $static() {\n    return (path) => {\n      return window.__tetra_staticRoot + path;\n    }\n  },\n  // Add WebSocket management methods\n  ensureWebSocketConnection() {\n    if (!this.ws || this.ws.readyState === WebSocket.CLOSED) {\n      console.log(\"Connecting to Tetra WebSocket...\");\n      const ws_scheme = window.location.protocol === \"https:\" ? \"wss\" : \"ws\";\n      const ws_url = `${ws_scheme}://${window.location.host}/ws/tetra/`;\n      this.ws = new WebSocket(ws_url);\n\n      // Suppress connection error messages in console by handling errors silently\n      this.ws.onerror = () => {\n        // Silently handle WebSocket errors to prevent console spam\n        // The onclose handler will manage reconnection logic\n      };\n\n      this.ws.onopen = () => {\n        Tetra.debug('Tetra WebSocket connected');\n        this.updateOnlineStatus();\n        document.dispatchEvent(new CustomEvent('tetra:websocket-connected'));\n        // Process any pending subscriptions\n        this.pendingSubscriptions.forEach((data, componentId) => {\n          this.ws.send(JSON.stringify(data));\n        });\n        this.pendingSubscriptions.clear();\n        // Process offline call queue\n        this.processOfflineCallQueue();\n      };\n\n      this.ws.onmessage = (event) => {\n        this.updateOnlineStatus();\n        const data = JSON.parse(event.data);\n        if (data.type === 'pong') {\n          if (this.pingTimeout) {\n            clearTimeout(this.pingTimeout);\n          }\n          return;\n        }\n        // Dispatch to all reactive components\n        // document.dispatchEvent(new CustomEvent('tetra:push-message', {detail: data}));\n        this.handleWebsocketMessage(data);\n      };\n\n      this.ws.onclose = () => {\n        console.log('Tetra WebSocket disconnected');\n        this.setOfflineStatus();\n        // Attempt to reconnect after 3 seconds\n        setTimeout(() => {\n          this.ensureWebSocketConnection();\n        }, 3000);\n      };\n    }\n    return this.ws;\n  },\n  _get_component_by_id(component_id) {\n    // Find the component by ID and return it\n    const componentEl = document.querySelector(`[tetra-component-id=\"${component_id}\"]`);\n    if (!componentEl) {\n      // silently return undefined if no component with that id was found.\n      return;\n    }\n    return Alpine.$data(componentEl);\n  },\n  _get_components_by_subscribe_group(group) {\n    // Find all components by subscribe topic and return them\n    const store = Alpine.store('tetra_subscriptions');\n    const componentIds = store[group] || [];\n    // Ensure we return a unique list of component data objects that actually exist in DOM\n    const components = componentIds.map(id => this._get_component_by_id(id))\n        .filter(c => !!c && typeof c._removeComponent === 'function');\n    return [...new Set(components)];\n  },\n  handleWebsocketMessage(data) {\n    // This function centrally handles incoming websocket data and dispatches it to the\n    // corresponding methods, if necessary.\n\n    let messageType;\n    let payload;\n    let metadata = {};\n\n    if (data.protocol !== \"tetra-1.0\") {\n      console.warn('Invalid or missing Tetra protocol in WebSocket message:', data);\n      return;\n    }\n\n    messageType = data.type;\n    payload = data.payload;\n    metadata = data.metadata || {};\n\n    switch (messageType) {\n      case 'subscription.response':\n        this.handleSubscriptionResponse(payload);\n        break;\n\n      case 'notify':\n        this.handleGroupNotify(payload);\n        break;\n\n      case 'component.data_changed':\n        this.handleComponentDataChanged(payload);\n        break;\n\n      case 'component.removed':\n        this.handleComponentRemoved(payload);\n        break;\n\n      case 'component.created':\n        this.handleComponentCreated(payload);\n        break;\n\n      default:\n        console.warn('Unknown WebSocket message type:', messageType, \":\", data);\n    }\n  },\n  handleSubscriptionResponse(event){\n    switch(event[\"status\"]) {\n      case \"subscribed\":\n        Tetra.debug(\"Subscription to group\", event[\"group\"], \"successful.\")\n        document.dispatchEvent(new CustomEvent(`tetra:component-subscribed`,  {\n          detail: {\n            component: this,\n            group: event[\"group\"]\n          },\n        }))\n        break;\n      case \"unsubscribed\":\n        Tetra.debug(\"Subscription to group\", event[\"group\"], \"redacted successfully.\")\n        document.dispatchEvent(new CustomEvent(`tetra:component-unsubscribed`,  {\n          detail: {\n            component: this,\n            group: event[\"group\"]\n          },\n        }))\n        break;\n      case \"resubscribed\":\n        Tetra.debug(\"Re-subscription to group\", event[\"group\"], \"successful.\")\n        document.dispatchEvent(new CustomEvent(`tetra:component-resubscribed`,  {\n          detail: {\n            component: this,\n            group: event[\"group\"]\n          },\n        }))\n        break;\n      case \"error\":\n        console.error(\"Error subscribing component\", event[\"component_id\"], \"to group\", event[\"group\"], \":\", event[\"message\"])\n        document.dispatchEvent(new CustomEvent(`tetra:component-subscription-error`,  {\n          detail: {\n            component: this,\n            group: event[\"group\"],\n            message:event[\"message\"]\n          },\n        }))\n        break;\n      default:\n        Tetra.debug(\"Subscription response faulty:\", event)\n    }\n  },\n  handleGroupNotify(event) {\n    /// Dispatch a custom event that was sent from the server as notification\n    const { group, event_name, data } = event;\n\n    // Dispatch group-specific event\n    document.dispatchEvent(new CustomEvent(event_name, {\n      detail: {\n        data,\n        group,\n      }\n    }));\n  },\n  handleComponentDataChanged(event) {\n    const { group, data, sender_id, update } = event;\n    const components = this._get_components_by_subscribe_group(group);\n    if (components.length === 0) {\n        // use [tetra-subscription] selector to find elements where the group is\n        // exactly matched.\n        const els = document.querySelectorAll(`[tetra-subscription=\"${group}\"]`);\n        els.forEach(el => {\n            const component = Alpine.$data(el);\n            if (component && !components.includes(component)) {\n                components.push(component);\n            }\n        });\n    }\n\n    // iter through components and update their data fields\n    components.forEach((component) => {\n      // Skip update if this component is currently waiting for a response\n      // from the request that triggered this server-side change.\n      if (\n        sender_id &&\n        component.__activeRequests &&\n        component.__activeRequests.has(sender_id)\n      ) {\n        return;\n      }\n      if (data && Object.keys(data).length > 0) {\n        component._updateData(data);\n      }\n      if (update || !data || Object.keys(data).length === 0) {\n        component._updateHtml().catch(err => {\n          console.error('Error updating component HTML:', err);\n        });\n      }\n    });\n  },\n  handleComponentRemoved(event) {\n    const { type, group, component_id, target_group, sender_id } = event;\n\n    if (component_id) {\n      const component = this._get_component_by_id(component_id)\n\n      if (component && component._removeComponent) {\n        if (\n          sender_id &&\n          component.__activeRequests &&\n          component.__activeRequests.has(sender_id)\n        ) {\n          return;\n        }\n        component._removeComponent();\n      }\n      return;\n    }\n\n    if (target_group) {\n      const components = this._get_components_by_subscribe_group(target_group);\n      if (components.length === 0) {\n        const els = document.querySelectorAll(`[tetra-subscription=\"${target_group}\"]`);\n        els.forEach(el => {\n          const component = Alpine.$data(el);\n          if (component && component._removeComponent) {\n            component._removeComponent();\n          }\n        });\n      }\n      components.forEach(component => {\n        if (component && component._removeComponent) {\n          if (\n            sender_id &&\n            component.__activeRequests &&\n            component.__activeRequests.has(sender_id)\n          ) {\n            return;\n          }\n          component._removeComponent();\n        }\n      });\n      return;\n    }\n\n    // Fallback: If no component_id or target_group is provided, find all \n    // components subscribed to the group and remove them.\n    const components = this._get_components_by_subscribe_group(group);\n    if (components.length === 0) {\n      const els = document.querySelectorAll(`[tetra-subscription=\"${group}\"]`);\n      els.forEach(el => {\n        const component = Alpine.$data(el);\n        if (component && component._removeComponent) {\n          component._removeComponent();\n        }\n      });\n    }\n    components.forEach(component => {\n      if (component && component._removeComponent) {\n        if (\n          sender_id &&\n          component.__activeRequests &&\n          component.__activeRequests.has(sender_id)\n        ) {\n          return;\n        }\n        component._removeComponent();\n      }\n    });\n  },\n  handleComponentCreated(event) {\n    const { group, data, component_id, target_group, sender_id } = event;\n    const components = this._get_components_by_subscribe_group(group);\n    components.forEach((component) => {\n      if (\n        sender_id &&\n        component.__activeRequests &&\n        component.__activeRequests.has(sender_id)\n      ) {\n        return;\n      }\n      component._updateHtml().catch(err => {\n        console.error('Error updating component HTML after creation:', err);\n      });\n    });\n  },\n\n  scheduleQueueRetry() {\n    // Schedule a retry attempt for queued calls after a short delay\n    if (this.queueRetryTimer) {\n      clearTimeout(this.queueRetryTimer);\n    }\n\n    // Only schedule if there are items in the queue\n    if (this.offlineCallQueue.length > 0) {\n      this.queueRetryTimer = setTimeout(() => {\n        this.processOfflineCallQueue();\n      }, 2000); // Retry after 2 seconds\n    }\n  },\n\n  async processOfflineCallQueue() {\n    if (this.offlineCallQueue.length === 0) return;\n\n    const queueLength = this.offlineCallQueue.length;\n    Tetra.debug(`Processing ${queueLength} queued calls from offline mode`);\n\n    // Notify that queue processing has started\n    document.dispatchEvent(new CustomEvent('tetra:queue-processing-start', {\n      detail: { queueLength }\n    }));\n\n    // Process calls in order - copy queue and clear original\n    const queue = [...this.offlineCallQueue];\n    this.offlineCallQueue = [];\n\n    // Process each queued call sequentially\n    for (const queuedCall of queue) {\n      try {\n        const { component, methodName, args, componentMetadata, preCallSnapshot, optimisticUpdate } = queuedCall;\n\n        // Look up component for event dispatching (may have moved or been destroyed)\n        // First try to find by component_id\n        let componentEl = document.querySelector(`[tetra-component-id=\"${component.component_id}\"]`);\n        let componentInstance = componentEl ? Alpine.$data(componentEl) : null;\n\n        // If found but key doesn't match, try to find by key instead\n        // This handles cases where component_id was reused for a different component\n        if (componentInstance && component.key && componentInstance.key !== component.key) {\n          Tetra.debug(`Component ID ${component.component_id} found but key mismatch, searching by key: ${component.key}`);\n\n          // Search all components with any ID to find matching key\n          const allComponents = document.querySelectorAll('[tetra-component-id]');\n          let foundByKey = false;\n          for (const el of allComponents) {\n            const comp = Alpine.$data(el);\n            if (comp && comp.key === component.key) {\n              componentEl = el;\n              componentInstance = comp;\n              foundByKey = true;\n              Tetra.debug(`Found component by key ${component.key} with ID ${comp.component_id}`);\n              break;\n            }\n          }\n\n          if (!foundByKey) {\n            componentEl = null;\n            componentInstance = null;\n          }\n        }\n\n        // Validate that we have the correct component by checking the key\n        // Component IDs can be reused in lists, so we must verify the key matches\n        const isCorrectComponent = componentInstance &&\n          (component.key === undefined || component.key === null || componentInstance.key === component.key);\n\n        if (!componentInstance || !isCorrectComponent) {\n          if (componentInstance && !isCorrectComponent) {\n            Tetra.debug(`Component ${component.component_id} found but key mismatch (queued: ${component.key}, found: ${componentInstance.key}), attempting replay with snapshot state: ${methodName}`);\n          } else {\n            Tetra.debug(`Component ${component.component_id} not found, attempting replay with snapshot state: ${methodName}`);\n          }\n\n          // Try to replay using snapshot state without a component instance\n          const success = await this.replayCallWithoutComponent(queuedCall);\n          if (success) {\n            Tetra.debug(`Successfully replayed ${methodName} without component instance`);\n          } else {\n            Tetra.debug(`Failed to replay ${methodName} - skipping`);\n          }\n          continue;\n        }\n\n        Tetra.debug(`Replaying queued call: ${methodName} (component_id: ${component.component_id}, key: ${component.key})`);\n\n        const requestId = Math.random().toString(36).substring(2, 15);\n        const triggerEl = componentInstance.$el;\n\n        // Get current state for the call\n        let component_state = Tetra.getStateWithChildren(componentInstance);\n        component_state.args = args || [];\n\n        // Get the unified endpoint\n        if (!componentInstance.__serverMethods || componentInstance.__serverMethods.length === 0) {\n          console.error('No server methods available for queued call');\n          continue;\n        }\n        const endpoint = componentInstance.__serverMethods[0].endpoint;\n\n        const metadata = componentMetadata || componentInstance.__componentMetadata;\n        const requestEnvelope = {\n          protocol: \"tetra-1.0\",\n          id: requestId,\n          type: \"call\",\n          payload: {\n            component_id: componentInstance.$el.getAttribute('tetra-component-id'),\n            method: methodName,\n            args: component_state.args,\n            state: component_state.data,\n            encrypted_state: component_state.encrypted,\n            children_state: component_state.children,\n            app_name: metadata.app_name,\n            library_name: metadata.library_name,\n            component_name: metadata.component_name,\n          }\n        };\n\n        // Prepare fetch payload\n        let fetchPayload = {\n          method: 'POST',\n          headers: {\n            'T-Request': \"true\",\n            'T-Current-URL': document.location.href,\n            'X-CSRFToken': window.__tetra_csrfToken,\n            'Content-Type': 'application/json'\n          },\n          mode: 'same-origin',\n          body: Tetra.jsonEncode(requestEnvelope)\n        };\n\n        // Dispatch before-request event\n        componentInstance.$dispatch('tetra:before-request', {\n          component: componentInstance,\n          triggerEl: triggerEl,\n          requestId: requestId\n        });\n\n        try {\n          const response = await fetch(endpoint, fetchPayload);\n\n          // Dispatch after-request event\n          componentInstance.$dispatch('tetra:after-request', {\n            component: componentInstance,\n            triggerEl: triggerEl,\n            requestId: requestId\n          });\n\n          // Handle different HTTP status codes with appropriate reconciliation strategies\n          if (response.status === 401 || response.status === 403) {\n            // Auth error - rollback optimistic changes\n            console.error(`Auth error (${response.status}) replaying queued call to ${methodName}, rolling back`);\n            this.rollbackOptimisticUpdate(componentInstance, preCallSnapshot);\n\n            componentInstance.$dispatch('tetra:call-rolled-back', {\n              component: componentInstance,\n              methodName: methodName,\n              status: response.status,\n              reason: 'auth_error'\n            });\n            continue; // Skip this call, don't retry\n          }\n\n          if (response.status === 409) {\n            // Conflict - refresh component from server\n            console.warn(`Conflict (409) replaying queued call to ${methodName}, refreshing component`);\n            await componentInstance._updateHtml().catch(err => {\n              console.error('Error refreshing component after conflict:', err);\n            });\n\n            componentInstance.$dispatch('tetra:call-conflict', {\n              component: componentInstance,\n              methodName: methodName\n            });\n            continue; // Call succeeded but state was stale, component refreshed\n          }\n\n          if (response.status >= 500) {\n            // Server error - rollback and re-queue for retry\n            console.warn(`Server error (${response.status}) replaying queued call to ${methodName}, will retry`);\n            this.rollbackOptimisticUpdate(componentInstance, preCallSnapshot);\n\n            // Re-queue at the end for retry\n            this.offlineCallQueue.push(queuedCall);\n            continue; // Continue processing other calls\n          }\n\n          if (!response.ok) {\n            // Other 4xx errors - rollback and log\n            console.error(`HTTP error ${response.status} replaying queued call to ${methodName}`);\n            this.rollbackOptimisticUpdate(componentInstance, preCallSnapshot);\n\n            componentInstance.$dispatch('tetra:call-failed', {\n              component: componentInstance,\n              methodName: methodName,\n              status: response.status\n            });\n            continue;\n          }\n\n          // Success (200) - parse response and apply updates\n          const result = await this.handleServerMethodResponse(response, componentInstance);\n\n          Tetra.debug(`Queued call ${methodName} completed successfully`);\n\n          componentInstance.$dispatch('tetra:call-reconciled', {\n            component: componentInstance,\n            methodName: methodName,\n            result: result\n          });\n\n        } catch (error) {\n          // Network error - rollback and re-queue at front\n          const isNetworkError = error instanceof TypeError &&\n            (error.message.includes('fetch') || error.message.includes('NetworkError'));\n\n          if (isNetworkError) {\n            console.warn('Network error during queue replay, rolling back and re-queuing:', error);\n            this.rollbackOptimisticUpdate(componentInstance, preCallSnapshot);\n\n            componentInstance.$dispatch('tetra:after-request', {\n              component: componentInstance,\n              triggerEl: triggerEl,\n              requestId: requestId\n            });\n\n            this.offlineCallQueue.unshift(queuedCall); // Put back at front\n            this.setOfflineStatus();\n            break; // Stop processing queue\n          }\n\n          // For other errors, log and continue\n          console.error('Error replaying queued call:', error);\n          componentInstance.$dispatch('tetra:after-request', {\n            component: componentInstance,\n            triggerEl: triggerEl,\n            requestId: requestId\n          });\n        }\n      } catch (error) {\n        console.error('Error processing queued call:', error);\n        // Continue with next call\n      }\n    }\n\n    // Schedule retry if there are still items in queue (server errors or network issues)\n    if (this.offlineCallQueue.length > 0) {\n      this.scheduleQueueRetry();\n    }\n\n    // Notify that queue processing has completed\n    document.dispatchEvent(new CustomEvent('tetra:queue-processing-complete', {\n      detail: {\n        processedCount: queueLength,\n        remainingCount: this.offlineCallQueue.length\n      }\n    }));\n  },\n\n  async replayCallWithoutComponent(queuedCall) {\n    // Replay a queued call when the component instance is not available in DOM\n    // This uses the snapshot state to reconstruct the request\n    const { component, methodName, args, componentMetadata, preCallSnapshot } = queuedCall;\n\n    if (!preCallSnapshot || !preCallSnapshot.data.__state) {\n      console.warn(`Cannot replay ${methodName} - no snapshot state available`);\n      return false;\n    }\n\n    const requestId = Math.random().toString(36).substring(2, 15);\n    const metadata = componentMetadata;\n\n    // Reconstruct the request envelope from snapshot\n    const requestEnvelope = {\n      protocol: \"tetra-1.0\",\n      id: requestId,\n      type: \"call\",\n      payload: {\n        component_id: component.component_id,\n        method: methodName,\n        args: args || [],\n        state: preCallSnapshot.data,\n        encrypted_state: preCallSnapshot.data.__state,\n        children_state: [],\n        app_name: metadata.app_name,\n        library_name: metadata.library_name,\n        component_name: metadata.component_name,\n      }\n    };\n\n    // Get endpoint from metadata or use default unified endpoint\n    const endpoint = '/tetra/call/';\n\n    const fetchPayload = {\n      method: 'POST',\n      headers: {\n        'T-Request': \"true\",\n        'T-Current-URL': document.location.href,\n        'X-CSRFToken': window.__tetra_csrfToken,\n        'Content-Type': 'application/json'\n      },\n      mode: 'same-origin',\n      body: Tetra.jsonEncode(requestEnvelope)\n    };\n\n    try {\n      const response = await fetch(endpoint, fetchPayload);\n\n      // Handle different status codes\n      if (response.status === 401 || response.status === 403) {\n        console.error(`Auth error (${response.status}) replaying ${methodName} without component - skipping`);\n        return false;\n      }\n\n      if (response.status === 409) {\n        console.warn(`Conflict (409) replaying ${methodName} without component - state was stale`);\n        return true; // Consider it handled\n      }\n\n      if (response.status >= 500) {\n        console.warn(`Server error (${response.status}) replaying ${methodName} without component - will retry`);\n        // Re-queue for retry\n        this.offlineCallQueue.push(queuedCall);\n        return false;\n      }\n\n      if (!response.ok) {\n        console.error(`HTTP error ${response.status} replaying ${methodName} without component`);\n        return false;\n      }\n\n      // Success - parse response\n      const respData = await response.json();\n\n      // Handle messages globally\n      if (respData.metadata?.messages) {\n        respData.metadata.messages.forEach((message) => {\n          document.dispatchEvent(new CustomEvent('tetra:new-message', { detail: message }));\n        });\n      }\n\n      // Dispatch global event for successful replay without component\n      document.dispatchEvent(new CustomEvent('tetra:call-replayed-without-component', {\n        detail: {\n          componentId: component.component_id,\n          methodName: methodName,\n          response: respData\n        }\n      }));\n\n      return true;\n    } catch (error) {\n      const isNetworkError = error instanceof TypeError &&\n        (error.message.includes('fetch') || error.message.includes('NetworkError'));\n\n      if (isNetworkError) {\n        console.warn('Network error during replay without component, re-queuing:', error);\n        this.offlineCallQueue.unshift(queuedCall);\n        this.setOfflineStatus();\n        return false;\n      }\n\n      console.error('Error replaying call without component:', error);\n      return false;\n    }\n  },\n\n  rollbackOptimisticUpdate(component, preCallSnapshot) {\n    if (!preCallSnapshot) return;\n\n    // Restore public state from snapshot\n    for (const key in preCallSnapshot.data) {\n      if (component.hasOwnProperty(key)) {\n        component[key] = preCallSnapshot.data[key];\n      }\n    }\n\n    // Restore HTML if available\n    if (preCallSnapshot.html && component.$el) {\n      try {\n        Alpine.morph(component.$root, preCallSnapshot.html, {\n          lookahead: true\n        });\n        Tetra.debug('Rolled back component HTML to pre-call state');\n      } catch (error) {\n        console.error('Error during rollback morph:', error);\n      }\n    }\n\n    component.$dispatch('tetra:state-rolled-back', { component: component });\n  },\n\n  captureComponentSnapshot(component) {\n    // Capture current component state for potential rollback\n    const snapshot = {\n      data: {},\n      html: component.$el ? component.$el.outerHTML : null,\n      timestamp: Date.now()\n    };\n\n    // Copy all public properties\n    for (const key in component) {\n      if (!key.startsWith('_') && !key.startsWith('$') && !key.startsWith('__') &&\n          typeof component[key] !== 'function') {\n        // Deep clone the value to prevent reference issues\n        try {\n          snapshot.data[key] = JSON.parse(JSON.stringify(component[key]));\n        } catch (e) {\n          // If value can't be serialized, store reference (best effort)\n          snapshot.data[key] = component[key];\n        }\n      }\n    }\n\n    // Capture encrypted state (needed for server-side validation)\n    if (component.__state) {\n      snapshot.data.__state = component.__state;\n    }\n\n    // Capture component metadata (needed for endpoint routing)\n    if (component.component_id) {\n      snapshot.component_id = component.component_id;\n    }\n    if (component.key) {\n      snapshot.key = component.key;\n    }\n\n    Tetra.debug(`Captured snapshot for component ${component.component_id} (key: ${component.key})`);\n    return snapshot;\n  },\n\n  queueOfflineCall(component, methodName, args, componentMetadata, preCallSnapshot, optimisticUpdate) {\n    Tetra.debug(`Queuing call to ${methodName} - connection offline`);\n\n    // Queue the call with all necessary context for replay\n    this.offlineCallQueue.push({\n      component: {\n        component_id: component.component_id,\n        key: component.key\n      },\n      methodName,\n      args,\n      componentMetadata,\n      preCallSnapshot, // Snapshot for rollback\n      optimisticUpdate, // Info about what was optimistically changed\n      queuedAt: Date.now()\n    });\n\n    // Dispatch event to notify that call was queued\n    component.$dispatch('tetra:call-queued', {\n      component: component,\n      methodName: methodName,\n      queueLength: this.offlineCallQueue.length\n    });\n\n    Tetra.debug(`Call queued: ${methodName}, component id: ${component.component_id} (queue length: ${this.offlineCallQueue.length})`);\n  },\n\n  sendWebSocketMessage(message) {\n    if (!this.ws) {\n      console.log(\"WebSocket is not connected. Cannot send message.\");\n      return\n    }\n    if (this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify(message));\n    } else {\n      // Store subscription messages until connection is ready\n      if (message.type === 'subscribe' && message.component_id) {\n        this.pendingSubscriptions.set(message.component_id, message);\n      }\n      // Queue other messages\n      this.ws.addEventListener('open', () => {\n        this.ws.send(JSON.stringify(message));\n      }, { once: true });\n    }\n  },\n  alpineComponentMixins() {\n    return {\n      // Alpine.js lifecycle:\n      init() {\n        this.component_id = this.$el.getAttribute('tetra-component-id');\n        this.$dispatch('tetra:child-component-init', {component:  this});\n        // Set component ID attribute on DOM element for targeting\n        this.__initServerWatchers();\n        this.__initStores();\n\n        // Auto-subscribe if component is reactive\n        if (window.__tetra_useWebsockets && this.$el.hasAttribute('tetra-reactive')) {\n          Tetra.ensureWebSocketConnection();\n\n          // Handle dynamic subscriptions from template\n          const group = this.$el.getAttribute('tetra-subscription');\n          if (group) {\n            this._subscribe(group);\n          }\n        }\n\n        if (this.__initInner) {\n          this.__initInner();\n        }\n\n        this._handleAutofocus();\n\n        const addClassToExternalIndicators = () => {\n          // adds `tetra-indicator` class to all elements targeted with `t-indicator` attribute\n          const elementsWithIndicator = [this.$el, ...Array.from(this.$el.querySelectorAll('[t-indicator]'))]\n          elementsWithIndicator.forEach(el => {\n            const indicators = el.getAttribute('t-indicator')\n            if (indicators) {\n              // If an explicit selector is given, hide it and add marker class to find it later\n              document.querySelectorAll(indicators).forEach(indicator => {\n                if (indicator.getAttribute('hidden') === null) {\n                  // indicator.setAttribute('hidden', '');\n                  indicator.hidden = true;\n                }\n                indicator.classList.add('tetra-indicator-' + this.component_id);\n              });\n            }\n          });\n        };\n        addClassToExternalIndicators();\n        this.$el.addEventListener('tetra:component-updated', addClassToExternalIndicators);\n\n        const handleRequestEvent = (event, isBefore) => {\n          const triggerEl = event.detail.triggerEl || event.target;\n          const requestId = event.detail.requestId;\n\n          if (!this.$el.contains(triggerEl) && this.$el !== triggerEl) return;\n\n          if (!this.__activeRequests) {\n            this.__activeRequests = new Map();\n          }\n\n          if (isBefore) {\n            let triggerSelector = '';\n            if (triggerEl.id) {\n              triggerSelector = '#' + triggerEl.id;\n            }\n            this.__activeRequests.set(requestId, {\n              triggerSelector: triggerSelector,\n              indicatorSelector: triggerEl.getAttribute('t-indicator'),\n              completed: false,\n            });\n          } else {\n            const request = this.__activeRequests.get(requestId);\n            if (request) {\n              request.completed = true;\n            }\n            // We keep it in the map for a short while after the request is \"completed\"\n            // to allow handleComponentUpdateData to catch late-arriving WS messages.\n            setTimeout(() => {\n              this.__activeRequests.delete(requestId);\n            }, 500);\n          }\n\n          const updateElementState = (el, reqId, isStart) => {\n            if (!el.__activeRequests) el.__activeRequests = new Set();\n            if (isStart) el.__activeRequests.add(reqId);\n            else el.__activeRequests.delete(reqId);\n            return el.__activeRequests.size > 0;\n          }\n\n          const hasActive = updateElementState(triggerEl, requestId, isBefore);\n          triggerEl.classList.toggle(\"tetra-request\", hasActive);\n\n          const selector = triggerEl.getAttribute('t-indicator');\n          if (selector) {\n            const localIndicators = Array.from(this.$el.querySelectorAll(selector))\n            const globalIndicators = Array.from(document.querySelectorAll('.tetra-indicator-' + this.component_id))\n\n            const allIndicators = new Set(localIndicators)\n            globalIndicators.forEach(el => {\n              if (el.matches(selector)) {\n                allIndicators.add(el)\n              }\n            })\n\n            allIndicators.forEach(el => {\n              const active = updateElementState(el, requestId, isBefore);\n              if (active) {\n                el.removeAttribute('hidden');\n                el.hidden = false;\n              } else {\n                el.setAttribute('hidden', '');\n                el.hidden = true;\n              }\n            })\n          }\n        };\n\n        const reapplyLoadingState = () => {\n          if (!this.__activeRequests || this.__activeRequests.size === 0) return;\n\n          this.__activeRequests.forEach((info, reqId) => {\n            // ONLY reapply if the request is NOT yet completed.\n            // If it is completed, it's only in the Map to block WS updates.\n            if (info.completed) return;\n\n            if (info.triggerSelector) {\n              const triggers = this.$el.querySelectorAll(info.triggerSelector);\n              triggers.forEach(el => {\n                if (!el.__activeRequests) el.__activeRequests = new Set();\n                el.__activeRequests.add(reqId);\n                el.classList.add(\"tetra-request\");\n              });\n            }\n            if (info.indicatorSelector) {\n              const localIndicators = Array.from(this.$el.querySelectorAll(info.indicatorSelector))\n              const globalIndicators = Array.from(document.querySelectorAll('.tetra-indicator-' + this.component_id))\n\n              const allIndicators = new Set(localIndicators)\n              globalIndicators.forEach(el => {\n                if (el.matches(info.indicatorSelector)) {\n                  allIndicators.add(el)\n                }\n              })\n              \n              allIndicators.forEach(el => {\n                if (!el.__activeRequests) el.__activeRequests = new Set();\n                el.__activeRequests.add(reqId);\n                el.removeAttribute('hidden');\n                el.hidden = false;\n              });\n            }\n          });\n        };\n\n        this.$el.addEventListener(\"tetra:before-request\", (event) => handleRequestEvent(event, true));\n        this.$el.addEventListener(\"tetra:after-request\", (event) => handleRequestEvent(event, false));\n        this.$el.addEventListener('tetra:component-updated', reapplyLoadingState);\n      },\n      destroy() {\n        this.$dispatch('tetra:child-component-destroy', {component:  this});\n\n        // Check if this component or any parent is currently updating\n        // to prevent unsubscription during morphing (could be a race condition!)\n        let isParentUpdating = false;\n        let current = this.$el.parentElement;\n        while (current) {\n          const parentComponent = current._x_dataStack?.[0];\n          if (parentComponent && parentComponent.__isUpdating) {\n            isParentUpdating = true;\n            break;\n          }\n          current = current.parentElement;\n        }\n\n        // Unsubscribe from all groups when component is destroyed\n        // but NOT if this component or a parent is being morphed/updated\n        // because it most probably is a replacement!\n        if (!this.__isUpdating && !isParentUpdating && this.__subscribedGroups) {\n          [...this.__subscribedGroups].forEach(group => {\n            this._unsubscribe(group);\n          });\n        }\n\n        if (this.__destroyInner) {\n          this.__destroyInner();\n        }\n      },\n      async _updateHtml(html) {\n        // If no HTML is provided, fetch it from the server\n        if (!html) {\n          html = await this._fetchHtml();\n        }\n\n        // Validate HTML before morphing\n        if (!html) return;\n\n        this.__isUpdating = true;\n        try {\n          Alpine.morph(this.$root, html, {\n            updating(el, toEl, childrenOnly, skip) {\n              if (toEl.hasAttribute && toEl.hasAttribute('x-data-maintain') && el.hasAttribute && el.hasAttribute('x-data')) {\n                toEl.setAttribute('x-data', el.getAttribute('x-data'));\n                toEl.removeAttribute('x-data-maintain');\n              } else if (toEl.hasAttribute && toEl.hasAttribute('x-data-update') && el.hasAttribute && el.hasAttribute('x-data')) {\n                let data = Tetra.jsonDecode(toEl.getAttribute('x-data-update'));\n                let old_data = Tetra.jsonDecode(toEl.getAttribute('x-data-update-old'));\n                let comp = window.Alpine.$data(el);\n                for (const key in data) {\n                  if (old_data.hasOwnProperty(key) && (old_data[key] !== comp[key])) {\n                    // If the data that was submitted to the server has since changed we don't overwrite it\n                    continue\n                  }\n                  comp[key] = data[key];\n                }\n                toEl.setAttribute('x-data', el.getAttribute('x-data'));\n                toEl.removeAttribute('x-data-update');\n              }\n            },\n            lookahead: true\n          });\n        } catch (error) {\n          console.error('Error during Alpine.morph:', error);\n          console.error('HTML that caused the error:', html);\n          // Don't throw - just log and continue\n        } finally {\n          this.__isUpdating = false;\n        }\n\n        this._handleAutofocus();\n        this.$dispatch('tetra:component-updated', { component: this });\n      },\n      _updateData(data) {\n        let activeEl = document.activeElement;\n        let focusedModel = null;\n        if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.tagName === 'SELECT') && this.$el.contains(activeEl)) {\n          // Check if the focused element is bound to a model\n          focusedModel = activeEl.getAttribute('x-model');\n          if (!focusedModel) {\n            // also check for x-model on parent elements, up to the component root\n            let el = activeEl.parentElement;\n            while (el && el !== this.$el && !focusedModel) {\n              focusedModel = el.getAttribute('x-model');\n              el = el.parentElement;\n            }\n          }\n        }\n\n        for (const key in data) {\n          if (focusedModel === key) {\n            Tetra.debug(`Skipping update for focused field: ${key}`);\n            continue;\n          }\n          this[key] = data[key];\n        }\n        // this._handleAutofocus(); // TODO: evaluate if this would make sense too\n        this.$dispatch('tetra:component-data-updated', { component: this });\n      },\n      _setValueByName(name, value){\n        // sets value to the input field with the given name\n        // This is especially useful for emptying a file field, as the browser doesn't do that on page refreshes.\n        let inputs = document.getElementsByName(name);\n        for (let i = 0; i < inputs.length; i++) {\n          inputs[i].value = value;\n        }\n      },\n      _removeComponent() {\n        this.$dispatch('tetra:component-before-remove', { component: this });\n        this.$root.remove();\n        Tetra.debug(`Removed component with key ${this.key} and ID ${this.component_id}`);\n      },\n      _replaceComponent(html) {\n        this.__isUpdating = true;\n        this.$dispatch('tetra:component-before-remove', { component: this });\n        this.$root.insertAdjacentHTML('afterend', html);\n        this.$root.remove();\n        this.__isUpdating = false;\n        this.$dispatch('tetra:component-updated', { component: this });\n        this._handleAutofocus();\n        Tetra.debug(`Replaced component with key ${this.key} and ID ${this.component_id}`);\n      },\n      _redirect(url) {\n        document.location = url;\n      },\n      _dispatch(name, data) {\n        this.$dispatch(name, {\n          _component: this,\n          ...data\n        });\n      },\n      _pushUrl(url, replace=false) {\n        if(replace){\n          window.history.replaceState(null, '', url);\n        } else {\n          window.history.pushState(null, '', url);\n        }\n      },\n      _updateSearchParam(param, value) {\n        const url = new URL(window.location);\n        if (value) {\n          url.searchParams.set(param, value);\n        } else {\n          url.searchParams.delete(param);\n        }\n        window.history.pushState(null, \"\", url.toString());\n      },\n      _handleAutofocus() {\n        this.$nextTick(() => {\n          if (!this.$root) {\n            return;\n          }\n          const focus_el = this.$root.querySelector(\"[autofocus]\");\n          if (focus_el) {\n            focus_el.focus();\n          }\n        });\n      },\n      async _fetchHtml() {\n        // Fetch fresh HTML from the server for this component by calling the special _refresh method\n        // The _refresh method uses the unified endpoint like all other methods\n        const refreshMethod = this.__serverMethods?.find(m => m.name === '_refresh');\n        if (!refreshMethod) {\n          throw new Error('_refresh method not found in component server methods');\n        }\n\n        // Use the standard callServerMethod for consistent behavior\n        // Pass the componentMetadata from this component instance\n        const result = await Tetra.callServerMethod(this, '_refresh', [], this.__componentMetadata);\n\n        // The result from _refresh contains the html in the response\n        return result?.html || result;\n      },\n\n      // Push notification methods\n      _subscribe(topic) {\n        if (!this.__subscribedGroups) {\n          this.__subscribedGroups = new Set();\n        }\n\n        const store = Alpine.store('tetra_subscriptions');\n        \n        this.__subscribedGroups.add(topic);\n        \n        if (!store[topic]) {\n          store[topic] = [];\n        }\n        \n        if (!store[topic].includes(this.component_id)) {\n          const isFirst = store[topic].length === 0;\n          store[topic].push(this.component_id);\n\n          if (isFirst) {\n            Tetra.sendWebSocketMessage({\n              type: 'subscribe',\n              group: topic,\n              component_id: this.component_id,\n              component_class: this.componentName,\n            });\n          }\n        }\n      },\n\n      _unsubscribe(topic) {\n        if (!this.__subscribedGroups) return;\n        const store = Alpine.store('tetra_subscriptions');\n\n        this.__subscribedGroups.delete(topic);\n\n        if (store[topic]) {\n          const index = store[topic].indexOf(this.component_id);\n          if (index > -1) {\n            store[topic].splice(index, 1);\n            const isLast = store[topic].length === 0;\n\n            // Check if ANY parent component is currently morphing\n            // If so, don't actually unsubscribe from the WebSocket - the component\n            // is likely being recreated during the morph\n            let isParentMorphing = false;\n            if (this.$el) {\n              let current = this.$el.parentElement;\n              while (current) {\n                const parentComponent = current._x_dataStack?.[0];\n                if (parentComponent && parentComponent.__isUpdating) {\n                  isParentMorphing = true;\n                  break;\n                }\n                current = current.parentElement;\n              }\n            }\n\n            if (isLast && !isParentMorphing) {\n              delete store[topic];\n              Tetra.sendWebSocketMessage({\n                type: 'unsubscribe',\n                group: topic,\n                component_id: this.component_id\n              });\n            } else if (isLast && isParentMorphing) {\n              // Don't delete from store or send unsubscribe - component is being recreated\n              if (window.__tetra_debug) {\n                Tetra.debug(`Skipping unsubscribe from ${topic} - parent is morphing, component likely being recreated`);\n              }\n            } else if (window.__tetra_debug) {\n              Tetra.debug(`Component ${this.component_id} unsubscribed from ${topic}, but ${store[topic].length} components still subscribed`);\n            }\n          }\n        }\n      },\n\n      _notifyGroup(groupName, eventName, data) {\n        return Tetra.sendWebSocketMessage({\n          type: 'notify',\n          group: groupName,\n          event_name: eventName,\n          data: data,\n          sender_id: this.component_id\n        });\n      },\n\n\n      // Tetra private:\n      __initServerWatchers() {\n        this.__serverMethods.forEach(item => {\n          if (item.watch) {\n            item.watch.forEach(propName => {\n              this.$watch(propName, async (value, oldValue) => {\n                await this[item.name](value, oldValue, propName);\n              })\n            })\n          }\n        })\n      },\n      __initStores() {\n        if (!this.__serverStores) return;\n\n        Object.entries(this.__serverStores).forEach(([propName, storePath]) => {\n          const parts = storePath.split('.');\n          const storeName = parts[0];\n          const propertyPath = parts.slice(1);\n\n          // Initialize store if it doesn't exist\n          if (!Alpine.store(storeName)) {\n            Alpine.store(storeName, {});\n          }\n\n          const getStoreValue = () => {\n            let val = Alpine.store(storeName);\n            for (const part of propertyPath) {\n              if (val === undefined || val === null || typeof val !== 'object') return undefined;\n              val = val[part];\n            }\n            return val;\n          };\n\n          const setStoreValue = (value) => {\n            if (propertyPath.length === 0) {\n              if (Alpine.store(storeName) !== value) {\n                Alpine.store(storeName, value);\n              }\n            } else {\n              let obj = Alpine.store(storeName);\n              for (let i = 0; i < propertyPath.length - 1; i++) {\n                const part = propertyPath[i];\n                if (!(part in obj) || typeof obj[part] !== 'object') obj[part] = {};\n                obj = obj[part];\n              }\n              const lastPart = propertyPath[propertyPath.length - 1];\n              if (obj[lastPart] !== value) {\n                obj[lastPart] = value;\n              }\n            }\n          };\n\n          // Track previous store value to detect actual store changes\n          let prevStoreVal = getStoreValue();\n\n          // Two-way sync: Store -> Component\n          Alpine.effect(() => {\n            const storeVal = getStoreValue();\n\n            // Only update component if the STORE value actually changed\n            if (storeVal !== prevStoreVal && storeVal !== undefined) {\n              prevStoreVal = storeVal;\n              if (this[propName] !== storeVal) {\n                this.__isSyncingFromStore = propName;\n                this[propName] = storeVal;\n                this.$nextTick(() => {\n                  if (this.__isSyncingFromStore === propName) {\n                    this.__isSyncingFromStore = null;\n                  }\n                });\n              }\n            }\n          });\n\n          // Two-way sync: Component -> Store\n          this.$watch(propName, (value) => {\n            if (this.__isSyncingFromStore !== propName) {\n              const currentStoreVal = getStoreValue();\n              if (currentStoreVal !== value) {\n                setStoreValue(value);\n                prevStoreVal = value; // Update tracking after successful store update\n              }\n            }\n          });\n\n          // Initial sync: Check if store already has a value\n          const initialStoreVal = getStoreValue();\n          if (initialStoreVal !== undefined) {\n            // Store already has a value (set by another component)\n            // Update component to match the store immediately\n            this[propName] = initialStoreVal;\n            prevStoreVal = initialStoreVal;\n          } else {\n            // Store doesn't have a value yet\n            // Initialize it with this component's value\n            setStoreValue(this[propName]);\n            prevStoreVal = this[propName];\n          }\n        });\n      },\n      __childComponents: {},\n      __rootBind: {\n        ['@tetra:child-component-init'](event) {\n          event.stopPropagation();\n          const comp = event.detail.component;\n          if (comp.key === this.key) {\n            return\n          }\n          if (comp.key) {\n            this.__childComponents[comp.key] = comp;\n          }\n          comp._parent = this;\n        },\n        ['@tetra:child-component-destroy'](event) {\n          event.stopPropagation();\n          const comp = event.detail.component;\n          if (comp.key === this.key) {\n            return\n          }\n          delete this.__childComponents[comp.key];\n          event.detail.component._parent = null;\n        }\n      }\n    }\n  },\n\n  makeServerMethods(serverMethods, componentMetadata) {\n    const methods = {};\n    serverMethods.forEach((serverMethod) => {\n      var func = async function(...args) {\n        // TODO: ensure only one concurrent?\n        return await Tetra.callServerMethod(this, serverMethod.name, args, componentMetadata)\n      }\n      if (serverMethod.debounce) {\n        func = Tetra.debounce(func, serverMethod.debounce, serverMethod.debounce_immediate)\n      } else if (serverMethod.throttle) {\n        func = Tetra.throttle(func, serverMethod.throttle, {\n          leading: serverMethod.throttle_leading,\n          trailing: serverMethod.throttle_trailing\n        })\n      }\n      methods[serverMethod.name] = func;\n    })\n    return methods\n  },\n\n  makeAlpineComponent(componentName, script, serverMethods, serverProperties, componentMetadata) {\n    Alpine.data(\n        componentName,\n        (initialDataJson) => {\n          const {init, destroy, ...script_rest} = script;\n          const initialData = Tetra.jsonDecode(initialDataJson);\n          const data = {\n            componentName,\n            __initInner: init,\n            __destroyInner: destroy,\n            __serverMethods: serverMethods,\n            __serverProperties: serverProperties,\n            __componentMetadata: componentMetadata,\n            __serverStores: initialData?.__serverStores,\n            ...(initialData || {}),\n            ...script_rest,\n            ...Tetra.makeServerMethods(serverMethods, componentMetadata),\n            ...Tetra.alpineComponentMixins(),\n          }\n          return data\n        }\n    )\n  },\n\n  getStateWithChildren(component) {\n    const data = {}\n    component.__serverProperties.forEach((key) => {\n      data[key] = component[key]\n    })\n    if (component.__serverStores) {\n      data[\"__serverStores\"] = component.__serverStores;\n    }\n    const r = {\n      encrypted: component.__state,\n      data: data,\n      children: []\n    }\n    for (const key in component.__childComponents) {\n      const comp = component.__childComponents[key];\n      r.children.push(Tetra.getStateWithChildren(comp));\n    }\n    return r;\n  },\n\n  loadScript(src) {\n    return new Promise((resolve, reject) => {\n      const script = document.createElement('script');\n      script.src = src;\n      script.onload = resolve;\n      script.onerror = reject;\n      document.head.appendChild(script);\n    });\n  },\n\n  loadStyles(href) {\n    return new Promise((resolve, reject) => {\n      const link = document.createElement('link');\n      link.href = href;\n      link.rel  = 'stylesheet';\n      link.type = 'text/css';\n      link.onload = resolve;\n      link.onerror = reject;\n      document.head.appendChild(link);\n    });\n  },\n  getFilenameFromContentDisposition(contentDisposition) {\n    if (!contentDisposition) return null;\n\n    // First, try to get the filename* parameter (RFC 5987)\n    let matches = /filename\\*=([^']*)'([^']*)'([^;]*)/i.exec(contentDisposition);\n    if (matches) {\n      // Decode the UTF-8 encoded filename\n      try {\n        return decodeURIComponent(matches[3]);\n      } catch (e) {\n        console.warn('Error decoding filename:', e);\n      }\n    }\n    // Try to get the regular filename parameter\n    matches = /filename=[\"']?([^\"';\\n]*)[\"']?/i.exec(contentDisposition);\n    if (matches) {\n      return matches[1];\n    }\n    return null;\n  },\n\n  async handleServerMethodResponse(response, component) {\n    // Handle 410 Gone - component state is stale (data was deleted)\n    if (response.status === 410) {\n      const responseText = await response.text();\n      const respData = Tetra.jsonDecode(responseText);\n\n      if (respData.error && respData.error.code === 'StaleComponentState') {\n        console.warn(`Component has stale state: ${respData.error.message}`);\n        // Gracefully remove the component from the DOM\n        if (component && component._removeComponent) {\n          component._removeComponent();\n        }\n        // Emit event for custom handling if needed\n        document.dispatchEvent(new CustomEvent('tetra:component-stale', {\n          detail: {\n            component: component,\n            error: respData.error\n          }\n        }));\n        return null;\n      }\n      // If not a stale state error, fall through to generic error handling\n    }\n\n    if (response.status === 200) {\n      const cd = response.headers.get('Content-Disposition')\n      if (cd?.startsWith(\"attachment\")) {\n        const a = document.createElement('a')\n        a.href = URL.createObjectURL(await response.blob())\n        a.download = this.getFilenameFromContentDisposition(cd)\n        a.click()\n        a.remove()\n        return;\n      }\n\n      const responseText = await response.text();\n      const respData = Tetra.jsonDecode(responseText);\n\n      let success = false;\n      let result = null;\n      let html = null;\n      let js = [];\n      let styles = [];\n      let messages = [];\n      let callbacks = [];\n\n      if (respData.protocol !== \"tetra-1.0\") {\n        throw new Error('Invalid or missing Tetra protocol in server response');\n      }\n\n      success = respData.success;\n      if (respData.payload) {\n        result = respData.payload.result;\n        html = respData.payload.html;\n      }\n      if (respData.metadata) {\n        js = respData.metadata.js || [];\n        styles = respData.metadata.styles || [];\n        messages = respData.metadata.messages || [];\n        callbacks = respData.metadata.callbacks || [];\n\n        // Fast lane for redirects\n        const redirectCallback = callbacks.find(item =>\n            item.callback && item.callback.length === 1 && item.callback[0] === '_redirect'\n        );\n        if (redirectCallback && redirectCallback.args && redirectCallback.args.length > 0) {\n          document.location = redirectCallback.args[0];\n          return;\n        }\n      }\n      if (!success && respData.error) {\n        console.error(`Tetra method error [${respData.error.code}]: ${respData.error.message}`);\n        // Emit event for custom error handling\n        document.dispatchEvent(new CustomEvent('tetra:method-error', {\n          detail: {\n            component: component,\n            error: respData.error\n          }\n        }));\n      }\n\n      // handle Django messages and emit \"tetra:new-message\" for each one\n      if (messages) {\n        messages.forEach((message) => {\n          component.$dispatch('tetra:new-message', message)\n        })\n      }\n\n      if (success) {\n        let loadingResources = [];\n        js.forEach(src => {\n          if (!document.querySelector(`script[src=\"${CSS.escape(src)}\"]`)) {\n            loadingResources.push(Tetra.loadScript(src));\n          }\n        })\n        styles.forEach(src => {\n          if (!document.querySelector(`link[href=\"${CSS.escape(src)}\"]`)) {\n            loadingResources.push(Tetra.loadStyles(src));\n          }\n        })\n        await Promise.all(loadingResources);\n\n        if (html) {\n          component._updateHtml(html);\n        }\n\n        if (callbacks) {\n          // Whitelist of allowed callback methods to prevent arbitrary code execution\n          const ALLOWED_CALLBACKS = new Set([\n            '_redirect', '_updateHtml', '_updateData', '_dispatch',\n            '_pushUrl', '_updateSearchParam', '_replaceComponent',\n            '_removeComponent', '_setValueByName'\n          ]);\n\n          callbacks.forEach((item) => {\n            // Validate callback structure\n            if (!item.callback || !Array.isArray(item.callback) || item.callback.length === 0) {\n              console.error('Invalid callback structure: missing or invalid callback array');\n              return;\n            }\n\n            const methodName = item.callback[0];\n\n            // Security check: only allow whitelisted top-level methods\n            if (!ALLOWED_CALLBACKS.has(methodName)) {\n              console.error(`Blocked disallowed callback method: ${methodName}`);\n              return;\n            }\n\n            // Security check: prevent prototype chain traversal\n            if (item.callback.some(name =>\n              name === '__proto__' || name === 'constructor' || name === 'prototype'\n            )) {\n              console.error('Blocked callback with dangerous property access');\n              return;\n            }\n\n            // iterate down path to callback\n            let obj = component;\n            try {\n              item.callback.forEach((name, i) => {\n                if (i === item.callback.length-1) {\n                  if (typeof obj[name] === 'function') {\n                    obj[name](...item.args);\n                  } else {\n                    console.error(`Callback target is not a function: ${name}`);\n                  }\n                } else {\n                  obj = obj[name];\n                }\n              });\n            } catch (e) {\n              console.error('Error executing callback:', e);\n            }\n          });\n        }\n        return result;\n      } else {\n        if (respData.error) {\n          throw new Error(`Error processing public method: ${respData.error.message}`);\n        }\n        throw new Error('Error processing public method');\n      }\n    } else {\n      throw new Error(`Server responded with an error ${response.status} (${response.statusText})`);\n    }\n  },\n\n  async callServerMethod(component, methodName, args, componentMetadata) {\n    const requestId = Math.random().toString(36).substring(2, 15);\n    const triggerEl = component.$event ? component.$event.target : component.$el;\n\n    // Debug: Log which component is being called\n    Tetra.debug(`callServerMethod: ${methodName} on component ${component.component_id} (key: ${component.key})`);\n\n    // Capture component snapshot BEFORE making any changes (for rollback)\n    const preCallSnapshot = this.captureComponentSnapshot(component);\n\n    // Get the unified endpoint URL from the first server method\n    // Note: _refresh is always added to server methods, so this should never be empty\n    if (!component.__serverMethods || component.__serverMethods.length === 0) {\n      console.error('No server methods available. Component may not be properly initialized.');\n      return Promise.reject(new Error('No server methods available'));\n    }\n    const endpoint = component.__serverMethods[0].endpoint;\n\n    // Use passed componentMetadata or fall back to component property\n    const metadata = componentMetadata || component.__componentMetadata;\n    if (!metadata) debugger\n\n    // Check if we're offline\n    // 1. Browser offline mode (DevTools or actual network)\n    // 2. WebSocket disconnected (for reactive components)\n    const isBrowserOffline = !navigator.onLine;\n    const isReactive = window.__tetra_useWebsockets && component.$el?.hasAttribute('tetra-reactive');\n    const isWebSocketOffline = isReactive && (!this.ws || this.ws.readyState !== WebSocket.OPEN);\n\n    // If offline, queue immediately with snapshot\n    if (isBrowserOffline || isWebSocketOffline) {\n      this.queueOfflineCall(component, methodName, args, metadata, preCallSnapshot, null);\n      return null;\n    }\n\n    // Prepare request\n    let component_state = Tetra.getStateWithChildren(component);\n    component_state.args = args || [];\n\n    const requestEnvelope = {\n      protocol: \"tetra-1.0\",\n      id: requestId,\n      type: \"call\",\n      payload: {\n        component_id: component.$el.getAttribute('tetra-component-id'),\n        method: methodName,\n        args: component_state.args,\n        state: component_state.data,\n        encrypted_state: component_state.encrypted,\n        children_state: component_state.children,\n        // Add component location metadata for the unified endpoint\n        app_name: metadata.app_name,\n        library_name: metadata.library_name,\n        component_name: metadata.component_name,\n      }\n    };\n\n    let fetchPayload = {\n      method: 'POST',\n      headers: {\n        'T-Request': \"true\",\n        'T-Current-URL': document.location.href,\n        'X-CSRFToken': window.__tetra_csrfToken,\n      },\n      mode: 'same-origin',\n    }\n\n    let formData = new FormData();\n    let hasFiles = false;\n    for(const [key, value] of Object.entries(component_state.data)){\n      // TODO: handle multi-file uploads\n      if (value instanceof File) {\n        hasFiles = true;\n        // A file is not uploaded anyway, as the browser automatically deletes the data if submitted within a JSON.\n        // On the server, only an empty {} will arrive, so we can set it to {} anyway.\n        // In the protocol, we keep the original state, but when sending we might need to adjust.\n        requestEnvelope.payload.state[key] = {};\n        formData.append(key, value);\n        // TODO: prevent re-uploading of files that are already uploaded.\n      }\n    }\n\n    // check if FormData has *any* entry - and if not, send JSON request\n    if (hasFiles) {\n      formData.append('tetra_payload', Tetra.jsonEncode(requestEnvelope));\n      fetchPayload.body = formData;\n    } else {\n      fetchPayload.body = Tetra.jsonEncode(requestEnvelope)\n      fetchPayload.headers['Content-Type'] = 'application/json'\n    }\n\n    component.$dispatch('tetra:before-request', {\n      component: component,\n      triggerEl: triggerEl,\n      requestId: requestId\n    });\n    this.updateOnlineStatus();\n\n    // Try to make the request, queue if network error occurs\n    try {\n      const response = await fetch(endpoint, fetchPayload);\n      component.$dispatch('tetra:after-request', {\n        component: component,\n        triggerEl: triggerEl,\n        requestId: requestId\n      })\n      const result = await this.handleServerMethodResponse(response, component);\n\n      // If there are queued calls and this request succeeded, schedule queue retry\n      if (this.offlineCallQueue.length > 0) {\n        this.scheduleQueueRetry();\n      }\n\n      return result;\n    } catch (error) {\n      // Check if it's a network error (connection refused, DNS failure, etc.)\n      const isNetworkError = error instanceof TypeError ||\n                            error.message.toLowerCase().includes('network') ||\n                            error.message.toLowerCase().includes('fetch');\n\n      if (isNetworkError) {\n        console.warn(`Network error calling ${methodName}, queueing for retry:`, error.message);\n\n        // Dispatch after-request to clear current loading state\n        component.$dispatch('tetra:after-request', {\n          component: component,\n          triggerEl: triggerEl,\n          requestId: requestId\n        });\n\n        // Queue the call for retry when connection is restored\n        this.queueOfflineCall(component, methodName, args, metadata, preCallSnapshot, null);\n\n        // Set offline status\n        this.setOfflineStatus();\n\n        return null;\n      }\n\n      // For other errors (like server errors), dispatch after-request and re-throw\n      component.$dispatch('tetra:after-request', {\n        component: component,\n        triggerEl: triggerEl,\n        requestId: requestId\n      });\n      throw error;\n    }\n  },\n\n  jsonReplacer(key, value) {\n    if (value instanceof Date) {\n      return {\n        __type: 'datetime',\n        value: value.toISOString(),\n      };\n    } else if (value instanceof Set) {\n      return {\n        __type: 'set',\n        value: Array.from(value)\n      };\n    }\n    // else if (value?.[0] instanceof File) {\n    //   return {\n    //     __type: 'file',\n    //     name: value[0].name,\n    //     value: value[0],\n    //     size: value[0].size,\n    //     content_type: value[0].type,\n    //   };\n    // }\n    return value;\n  },\n\n  jsonReviver(key, value) {\n    if (value && typeof value === 'object' && value.__type) {\n      if (value.__type === 'datetime') {\n        return new Date(value);\n      } else if (value.__type === 'set') {\n        return new Set(value);\n      }\n    }\n    return value\n  },\n\n  jsonEncode(obj) {\n    return JSON.stringify(obj, Tetra.jsonReplacer);\n  },\n\n  jsonDecode(s) {\n    return JSON.parse(s, Tetra.jsonReviver)\n  },\n\n  debounce(func, wait, immediate) {\n    var timeout\n    return function() {\n      var context = this, args = arguments\n      var later = function () {\n        timeout = null\n        if (!immediate) func.apply(context, args);\n      }\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) func.apply(context, args);\n    }\n  },\n\n  throttle(func, wait, options) {\n    // From Underscore.js\n    // https://underscorejs.org\n    // (c) 2009-2022 Jeremy Ashkenas, Julian Gonggrijp, and DocumentCloud and\n    // Investigative Reporters & Editors\n    // Underscore may be freely distributed under the MIT license.\n    // --\n    // Returns a function, that, when invoked, will only be triggered at most once\n    // during a given window of time. Normally, the throttled function will run\n    // as much as it can, without ever going more than once per `wait` duration;\n    // but if you'd like to disable the execution on the leading edge, pass\n    // `{leading: false}`. To disable execution on the trailing edge, ditto.\n    var timeout, context, args, result;\n    var previous = 0;\n    if (!options) options = {};\n\n    var later = function() {\n      previous = options.leading === false ? 0 : Date.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n\n    var throttled = function() {\n      var _now = Date.now();\n      if (!previous && options.leading === false) previous = _now;\n      var remaining = wait - (_now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = _now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n\n    throttled.cancel = function() {\n      clearTimeout(timeout);\n      previous = 0;\n      timeout = context = args = null;\n    };\n\n    return throttled;\n  }\n\n}\n\nexport default Tetra;\n", "import Tetra from './tetra.core'\n\nwindow.Tetra = Tetra;\nwindow.document.addEventListener('alpine:init', () => {\n  Tetra.init();\n})\n"],
  "mappings": "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",
  "names": ["Tetra", "args", "defaultTimeout", "store", "timeout", "messages", "message", "path", "ws_url", "data", "componentId", "event", "component_id", "componentEl", "group", "components", "id", "c", "messageType", "payload", "metadata", "event_name", "sender_id", "update", "el", "component", "err", "type", "target_group", "queueLength", "queue", "queuedCall", "methodName", "componentMetadata", "preCallSnapshot", "optimisticUpdate", "componentInstance", "allComponents", "foundByKey", "comp", "isCorrectComponent", "requestId", "triggerEl", "component_state", "endpoint", "requestEnvelope", "fetchPayload", "response", "result", "error", "_a", "respData", "key", "snapshot", "addClassToExternalIndicators", "indicators", "indicator", "handleRequestEvent", "isBefore", "triggerSelector", "request", "updateElementState", "reqId", "isStart", "hasActive", "selector", "localIndicators", "globalIndicators", "allIndicators", "reapplyLoadingState", "info", "isParentUpdating", "current", "parentComponent", "html", "toEl", "childrenOnly", "skip", "old_data", "activeEl", "focusedModel", "name", "value", "inputs", "i", "url", "replace", "param", "focus_el", "m", "topic", "isFirst", "index", "isLast", "isParentMorphing", "groupName", "eventName", "item", "propName", "oldValue", "storePath", "parts", "storeName", "propertyPath", "getStoreValue", "val", "part", "setStoreValue", "obj", "lastPart", "prevStoreVal", "storeVal", "initialStoreVal", "serverMethods", "methods", "serverMethod", "func", "componentName", "script", "serverProperties", "initialDataJson", "init", "destroy", "script_rest", "initialData", "src", "resolve", "reject", "href", "link", "contentDisposition", "matches", "e", "responseText", "cd", "a", "success", "js", "styles", "callbacks", "redirectCallback", "loadingResources", "ALLOWED_CALLBACKS", "isBrowserOffline", "isWebSocketOffline", "formData", "hasFiles", "s", "wait", "immediate", "context", "later", "callNow", "options", "previous", "throttled", "_now", "remaining", "tetra_core_default", "tetra_core_default"]
}
